# Data Structures and Programming
# Структури от Данни и Програмиране

- [Data Structures and Programming](#data-structures-and-programming)
- [Структури от Данни и Програмиране](#структури-от-данни-и-програмиране)
  - [Изчислителна сложност _Computational Complexity_](#изчислителна-сложност-computational-complexity)
  - [Качество и тестване на кода _Quality and Code Testing_](#качество-и-тестване-на-кода-quality-and-code-testing)
  - [Абстрактни структури от данни _Abstract Data Structures_](#абстрактни-структури-от-данни-abstract-data-structures)
  - [Динамичен масив _Dynamic Array, Vector_](#динамичен-масив-dynamic-array-vector)
    - [Масив](#масив)
    - [Реализация](#реализация)
  - [Итератор върху структура _Iterator Design Pattern_](#итератор-върху-структура-iterator-design-pattern)
- [Notes](#notes)

## Изчислителна сложност _Computational Complexity_
- Сложност - мярка, която измерва в определена единица 
  използваните от програмата ресурси
  - Времева _Temporal_
  - Пространствена _Spatial_
- Сложност по време
  - Асимптотична оценка за времето за работа на алгоритъма 
    спрямо размера на данните
  - Обикновено се измерва за време с брой операции
- Сложност по памет
  - Оценка за използваните от алгоритъма ресурси памет
  - Стандартно всеки алгоритъм изисква $O(1) + O(N)$ 
    допълнителна памет
  - Сложността по памет не може да надхвърля сложността по 
    време $O_{memory} ≤ O_{time}$ понеже достъпът по памет 
    е единична операция
- Функция `alg`
  - $alg ∈ O(f) ⇒ alg < f$
  - $alg ∈ Θ(f) ⇒ alg = f ((alg ∈ O(f)) and (alg ∈ Ω(f)))$
  - $alg ∈ Ω(f) ⇒ alg > f$
  - Пример: `alg` $∈ O(N^2) →$ `alg` завършва за време не 
    повече от $N^2$
- Ползва се главно за да сравни различни имплементации 
  (алгоритми) за решаване на определен проблем
- Възможно е един алгоритъм да се имплементира по различни 
  начини и съответно да е с различна хардуерна и логическа 
  сложност (откъм ползваните структури от данни)
- За практически цели се използва **O(f)** сложността на 
  алгоритъма по време (най-лош случай) и **Ω(f)** 
  сложността на алгоритъма по памет (минимални необходими 
  ресурси)
- Пропускат се маловажни операции в алгоритъма, процесорите 
  са оптимизирани за операциите инкрементиране, присвояване 
  и сравняване на числа, индексиране в масив
- Пример: алгоритъм сортиране по метода на пряката селекция
    ``` cpp
    // N*N + N complexity
    // Θ(N^2)*(comparisons) + Θ(N)*(swap) = O(N^2)
    void selectionSort(int arr[], int n) {
      for (int i = 0; i < n - 1; ++i) {
        x = minIndex(arr, i, n); // N iterations
        swap(a[i], a[x]); // N iterations
      }
    }

    int minIndex(int arr[], int from, int to) {
      int min = from;
      for (int i = from + 1; i < to; ++i)
        if (arr[min] > arr[i]) min = i; // N iterations
      return min;
    }
    ```
- Видове оценки
  - Най-добър случай
    - С най-голяма сложност
  - Най-лош случай
    - С най-малка сложност
  - Очаквана сложност (случай)
    - Най-често случваща се в случайна ситуация
    - Трудна за пресмятане
  - Средна сложност (случай)
    - Пресметната от общото време за всички случаи, 
      разделено на общия брой случаи
    - Трудна за пресмятане
  - Амортизирана сложност
    - Средна сложност при многократно изпълняване на една и 
      съща операция при един и същ контекст
    - Амортизираната сложност на сортирането е константа 
      (но няма логика, не е приложимо да се сортира вече 
      сортиран масив)
- Различните/еднаквите класове не гарантират, че и 
  алгоритмите няма да са с различна/еднаква ефективност
- Сортирането има стандартно O(N*log(N)) сложност, O(N) за 
  предварително известни данни, O(log(N)) за устройства с N
  процесора (паралелни алгоритми)
- Понякога е необходимо за един алгоритъм да се разгледа 
  над какви структури от данни работи и за кои операции с 
  каква сложност е
  - Например сравняване и присвояване между различни 
    структури
- Big-O notation
  1. $O(1)$
  2. $O(log(N))$
  3. $O(√N)$
  4. $O(N)$
  5. $O(N log(N))$
  6. $O(N^2)$
  7. $O(2^N)$
  8. $O(N!)$
  9. $O(N^N)$
  - **O(1)** - константно, не зависи от вида на входа, 
    завършва за едно и също време
  - **O(N)** - линейно, ресурсите и времето зависят от вида 
    на входа
- |Сложност/Вход |  1|  2|  3|      10|
  |--------------|--:|--:|--:|-------:|
  |$O(1)$        |  1|  1|  1|       1|
  |$O(log(N))$   |  1|  1|  2|       4|
  |$O(N)$        |  1|  2|  3|      10|
  |$O(N log(N))$ |  1|  2|  5|      34|
  |$O(N^2)$      |  1|  4|  9|     100|
  |$O(2^N)$      |  1|  4|  8|    1024|
  |$O(N!)$       |  1|  2|  6| 3628800|

## Качество и тестване на кода _Quality and Code Testing_
- Устойчивост на кода след времето
- **Unit tests**
  - Прости, малки и работят бързо, тестват малко парче код 
    (една функция) ползват се главно за публичен интерфейс
- **Integration tests**
  - Проверяват дали отделните тествани с unit тестове 
    модули работят правилно
- **Functional tests**
  - Проверяват цяла функционалност на определен сценарий
- **Acceptance tests**
  - Дефинира се за даден проект от потребителя
- **Smoke test**
  - Малък и бърз тест, който за обемен софтуер бързо 
    проверява дали изобщо работи или нещо критично е 
    повредено, проверява целия продукт
- **Code coverage**
  - Метрика колко реда (процента) от кода е покрит с 
    тестове
- **Mocking**
  - Малък клас или метод, който има необходим интерфейс 
    (например на база данни), който се ползва в тестовете, 
    за да не се работи с реалния обект

## Абстрактни структури от данни _Abstract Data Structures_
- Абстрактна структура от данни
  - Абстрактно понятие, дефинира основните операции над 
    структурата, свойства, характеристики (сложност по 
    време и памет), допълнителни изисквания
- Основни операции
  - Създаване на структурата
  - Заявки към данните
    - Наличие на елемент с определено свойство
    - Извличане на елемент с определено свойство
  - Промяна на структурата
    - Добавяне на елемент
    - Премахване на елемент
    - Промяна на елемент
- Носител
  - Техническо представяне на данните в паметта на 
    компютъра
- Обработка на грешки
- Структури, които не позволяват промяна на данните се 
  наричат `immutable` (непроменяеми)

## Динамичен масив _Dynamic Array, Vector_
### Масив
- Характеристики
  - **C** - капацитет
  - **N** - брой елементи $(max(Init, N) <= C <= 2N)$
- Свойства
  - Линейна структура (всеки елемент има уникален индекс)
    - Ако има елемент с индекс i и такъв с индекс j, то има
      елементи с индекси за всяко k ∈ [i, j] 
      (непрекъснатост)
  - Всички елементи са от един и същ тип
- Операции *(N-брой, C-капацитет, N≤C)*
  - Създаване на структурата - **O(C)**
    - С фиксиран размер (капацитет C)
  - Достъп до индекс (четене/запис) - **O(1)** 
    - Четене на капацитет C и брой N
  - Промяна на капацитета (динамичен масив) - **O(C)**
  - Индексация
    - За `C++` е в интервала $[0, N)$, за `Pascall` е 
      $[b, b+N)$
- Носител
  - За ДМ се ползва динамично заделен масив

### Реализация
- Необходима функционалност на ДМ (основни операции)
  - Създаване **O(C)**
  - Премахване на всички елементи **O(C)**
  - Търсене по стойност **O(N)**
  - Достъп по номер на елемент **O(1)**
  - Добавяне/премахване по индекс
    - В началото **O(N)**
    - В края **O(1)A**
    - На произволна позиция **O(N)**
  - Преоразмеряване (разширяване/намаляване) на капацитета 
    **O(C)**
- Реализация
  - Език `C++`, `class`
  - Шаблонен `template` по типа данни
  - Носител - последователна памет чрез `new`
  - Помощни вложени методи (конструктор, деструктор)
- Оператор `[]` предполага достъп до елемент с константна 
  сложност, метод `get` се ползва в друг случай
- Операциите за индексиране по стандарт не проверяват 
  коректност на индекса, докато `get` и `at` са по-бавни, 
  но проверяват валидност

## Итератор върху структура _Iterator Design Pattern_
- Абстрактен обект
  - Дава достъп до всички елементи в СД в определен ред
  - Свързан е с даден елемент
- Характеристика (операции)
  - Създаване на итератор, свързан с определен елемент от 
    структурата от данни (първи, последен) **O(1)**
    - Чрез метод на СД
  - Извличане на стойност на свързан елемент **O(1)**
    - `operator*`, `operator[]`
  - Преминаване (свързване) към следващ елемент **O(1)**
    - `operator++`, `operator--`
    - Минаване през всички елементи на СД за общо линейно 
      време **O(N)**
  - Проверка дали има следващ елемент **O(1)**
    - `operator!`
  - Допълнително могат да се реализират и `operator<`, 
    `operator==`, `operator!=` за указатели
    ```c++
    for (T it=array.begin(); // begin() - first element
         it !=array.end()    // end() - invalid element
         /*it.hasNext()*/;
         ++it) {
      std::cout << *it;
    }

    for (DataType &d : array) // Needs begin() and end()
      std::cout << d;
    ```

# Notes
- СДП - ФМИ - 2021г. 2022г.
- Всички записки са направени благодарение на лекторите по 
  предмета - П. Армянов, А. Семерджиев