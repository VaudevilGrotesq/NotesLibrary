# Data Structures and Programming
# Структури от Данни и Програмиране

- [Data Structures and Programming](#data-structures-and-programming)
- [Структури от Данни и Програмиране](#структури-от-данни-и-програмиране)
  - [Изчислителна сложност _Computational Complexity_](#изчислителна-сложност-computational-complexity)
  - [Качество и тестване на кода _Quality and Code Testing_](#качество-и-тестване-на-кода-quality-and-code-testing)
  - [Абстрактни структури от данни _Abstract Data Structures_](#абстрактни-структури-от-данни-abstract-data-structures)
  - [Динамичен масив _Dynamic Array, Vector_](#динамичен-масив-dynamic-array-vector)
    - [Масив](#масив)
    - [Реализация](#реализация)
  - [Итератор върху структура _Iterator Design Pattern_](#итератор-върху-структура-iterator-design-pattern)
  - [Свързан списък _Linked List_](#свързан-списък-linked-list)
  - [Линеен едносвързан списък _Linked List_](#линеен-едносвързан-списък-linked-list)
  - [Цикличен едносвързан списък _Linked List_](#цикличен-едносвързан-списък-linked-list)
  - [Линеен двусвързан списък _Doubly-linked List_](#линеен-двусвързан-списък-doubly-linked-list)
- [Notes](#notes)

## Изчислителна сложност _Computational Complexity_
- Сложност - мярка, която измерва в определена единица 
  използваните от програмата ресурси
  - Времева _Temporal_
  - Пространствена _Spatial_
- Сложност по време
  - Асимптотична оценка за времето за работа на алгоритъма 
    спрямо размера на данните
  - Обикновено се измерва за време с брой операции
- Сложност по памет
  - Оценка за използваните от алгоритъма ресурси памет
  - Стандартно всеки алгоритъм изисква $O(1) + O(N)$ 
    допълнителна памет
  - Сложността по памет не може да надхвърля сложността по 
    време $O_{memory} ≤ O_{time}$ понеже достъпът по памет 
    е единична операция
- Функция `alg`
  - $alg ∈ O(f) ⇒ alg < f$
  - $alg ∈ Θ(f) ⇒ alg = f ((alg ∈ O(f)) and (alg ∈ Ω(f)))$
  - $alg ∈ Ω(f) ⇒ alg > f$
  - Пример: `alg` $∈ O(N^2) →$ `alg` завършва за време не 
    повече от $N^2$
- Ползва се главно за да сравни различни имплементации 
  (алгоритми) за решаване на определен проблем
- Възможно е един алгоритъм да се имплементира по различни 
  начини и съответно да е с различна хардуерна и логическа 
  сложност (откъм ползваните структури от данни)
- За практически цели се използва **O(f)** сложността на 
  алгоритъма по време (най-лош случай) и **Ω(f)** 
  сложността на алгоритъма по памет (минимални необходими 
  ресурси)
- Пропускат се маловажни операции в алгоритъма, процесорите 
  са оптимизирани за операциите инкрементиране, присвояване 
  и сравняване на числа, индексиране в масив
- Пример: алгоритъм сортиране по метода на пряката селекция
    ``` cpp
    // N*N + N complexity
    // Θ(N^2)*(comparisons) + Θ(N)*(swap) = O(N^2)
    void selectionSort(int arr[], int n) {
      for (int i = 0; i < n - 1; ++i) {
        x = minIndex(arr, i, n); // N iterations
        swap(a[i], a[x]); // N iterations
      }
    }

    int minIndex(int arr[], int from, int to) {
      int min = from;
      for (int i = from + 1; i < to; ++i)
        if (arr[min] > arr[i]) min = i; // N iterations
      return min;
    }
    ```
- Видове оценки
  - Най-добър случай
    - С най-голяма сложност
  - Най-лош случай
    - С най-малка сложност
  - Очаквана сложност (случай)
    - Най-често случваща се в случайна ситуация
    - Трудна за пресмятане
  - Средна сложност (случай)
    - Пресметната от общото време за всички случаи, 
      разделено на общия брой случаи
    - Трудна за пресмятане
  - Амортизирана сложност
    - Средна сложност при многократно изпълняване на една и 
      съща операция при един и същ контекст
    - Амортизираната сложност на сортирането е константа 
      (но няма логика, не е приложимо да се сортира вече 
      сортиран масив)
- Различните/еднаквите класове не гарантират, че и 
  алгоритмите няма да са с различна/еднаква ефективност
- Сортирането има стандартно O(N*log(N)) сложност, O(N) за 
  предварително известни данни, O(log(N)) за устройства с N
  процесора (паралелни алгоритми)
- Понякога е необходимо за един алгоритъм да се разгледа 
  над какви структури от данни работи и за кои операции с 
  каква сложност е
  - Например сравняване и присвояване между различни 
    структури
- Big-O notation
  1. $O(1)$
  2. $O(log(N))$
  3. $O(√N)$
  4. $O(N)$
  5. $O(N log(N))$
  6. $O(N^2)$
  7. $O(2^N)$
  8. $O(N!)$
  9. $O(N^N)$
  - **O(1)** - константно, не зависи от вида на входа, 
    завършва за едно и също време
  - **O(N)** - линейно, ресурсите и времето зависят от вида 
    на входа
- |Сложност/Вход |  1|  2|  3|      10|
  |--------------|--:|--:|--:|-------:|
  |$O(1)$        |  1|  1|  1|       1|
  |$O(log(N))$   |  1|  1|  2|       4|
  |$O(N)$        |  1|  2|  3|      10|
  |$O(N log(N))$ |  1|  2|  5|      34|
  |$O(N^2)$      |  1|  4|  9|     100|
  |$O(2^N)$      |  1|  4|  8|    1024|
  |$O(N!)$       |  1|  2|  6| 3628800|

## Качество и тестване на кода _Quality and Code Testing_
- Устойчивост на кода след времето
- **Unit tests**
  - Прости, малки и работят бързо, тестват малко парче код 
    (една функция) ползват се главно за публичен интерфейс
- **Integration tests**
  - Проверяват дали отделните тествани с unit тестове 
    модули работят правилно
- **Functional tests**
  - Проверяват цяла функционалност на определен сценарий
- **Acceptance tests**
  - Дефинира се за даден проект от потребителя
- **Smoke test**
  - Малък и бърз тест, който за обемен софтуер бързо 
    проверява дали изобщо работи или нещо критично е 
    повредено, проверява целия продукт
- **Code coverage**
  - Метрика колко реда (процента) от кода е покрит с 
    тестове
- **Mocking**
  - Малък клас или метод, който има необходим интерфейс 
    (например на база данни), който се ползва в тестовете, 
    за да не се работи с реалния обект

## Абстрактни структури от данни _Abstract Data Structures_
- Абстрактна структура от данни
  - Абстрактно понятие, дефинира основните операции над 
    структурата, свойства, характеристики (сложност по 
    време и памет), допълнителни изисквания
- Основни операции
  - Създаване на структурата
  - Заявки към данните
    - Наличие на елемент с определено свойство
    - Извличане на елемент с определено свойство
  - Промяна на структурата
    - Добавяне на елемент
    - Премахване на елемент
    - Промяна на елемент
- Носител
  - Техническо представяне на данните в паметта на 
    компютъра
- Обработка на грешки
- Структури, които не позволяват промяна на данните се 
  наричат `immutable` (непроменяеми)

## Динамичен масив _Dynamic Array, Vector_
### Масив
- Характеристики
  - **C** - капацитет
  - **N** - брой елементи $(max(Init, N) <= C <= 2N)$
- Свойства
  - Линейна структура (всеки елемент има уникален индекс)
    - Ако има елемент с индекс i и такъв с индекс j, то има
      елементи с индекси за всяко k ∈ [i, j] 
      (непрекъснатост)
  - Всички елементи са от един и същ тип
- Операции *(N-брой, C-капацитет, N≤C)*
  - Създаване на структурата - **O(C)**
    - С фиксиран размер (капацитет C)
  - Достъп до индекс (четене/запис) - **O(1)** 
    - Четене на капацитет C и брой N
  - Промяна на капацитета (динамичен масив) - **O(C)**
  - Индексация
    - За `C++` е в интервала $[0, N)$, за `Pascall` е 
      $[b, b+N)$
- Носител
  - За ДМ се ползва динамично заделен масив

### Реализация
- Необходима функционалност на ДМ (основни операции)
  - Създаване **O(C)**
  - Премахване на всички елементи **O(C)**
  - Търсене по стойност **O(N)**
  - Достъп по номер на елемент **O(1)**
  - Добавяне/премахване по индекс
    - В началото **O(N)**
    - В края **O(1)A**
    - На произволна позиция **O(N)**
  - Преоразмеряване (разширяване/намаляване) на капацитета 
    **O(C)**
- Реализация
  - Език `C++`, `class`
  - Шаблонен `template` по типа данни
  - Носител - последователна памет чрез `new`
  - Помощни вложени методи (конструктор, деструктор)
- Оператор `[]` предполага достъп до елемент с константна 
  сложност, метод `get` се ползва в друг случай
- Операциите за индексиране по стандарт не проверяват 
  коректност на индекса, докато `get` и `at` са по-бавни, 
  но проверяват валидност

## Итератор върху структура _Iterator Design Pattern_
- Абстрактен обект
  - Дава достъп до всички елементи в СД в определен ред
  - Свързан е с даден елемент
- Характеристика (операции)
  - Създаване на итератор, свързан с определен елемент от 
    структурата от данни (първи, последен) **O(1)**
    - Чрез метод на СД
  - Извличане на стойност на свързан елемент **O(1)**
    - `operator*`, `operator[]`
  - Преминаване (свързване) към следващ елемент **O(1)**
    - `operator++`, `operator--`
    - Минаване през всички елементи на СД за общо линейно 
      време **O(N)**
  - Проверка дали има следващ елемент **O(1)**
    - `operator!`
  - Допълнително могат да се реализират и `operator<`, 
    `operator==`, `operator!=` за указатели
    ``` cpp
    for (T it=array.begin(); // begin() - first element
         it !=array.end()    // end() - invalid element
         /*it.hasNext()*/;
         ++it) {
      std::cout << *it;
    }

    for (DataType &d : array) // Needs begin() and end()
      std::cout << d;
    ```

## Свързан списък _Linked List_
- Линейна структура от данни, в която всеки елемент е 
  свързан със следващия си и съществува единствен елемент 
  без следващ наследник (последен)
- За линейна структура данни се дефинира релация `next`
- Операции
  - Добавяне на позоция
    - По относителна позиция 
  - Достъп за четене по позоция
    - По относителна позиция 
    - По свойство на данните (критерий)
  - Премахване
    - По относителна позиция 
    - По свойство на данните (критерий)
  - Обхождане - последователен достъп до всички елементи
  - Операциите по критерий са: по относителна позиция 
    (след/преди даден елемент), по абсолютна позиция 
    (спрямо начало/край), по свойство на данните, като 
    абсолютната се свейда до относителна

## Линеен едносвързан списък _Linked List_
- Всеки елемент има единствен указател, свързващ го със 
  следващия
- Операции
  - Добавяне в началото **O(1)**
  - Добавяне в края **O(1)**
  - Четене в началото/края **O(1)**
  - Премахване в началото **O(1)**
  - Добавяне/премахване на произволна позиция **O(N)**
  - Четене на произволна позиция **O(N)**
  - Обхождане **O(N)** за N елемента, тоест **O(1)** за 
    всеки
  - Конкатенация **O(1)**
  - Четене/премахване/добавяне след даден елемент **O(1)**
  - Достъп до елемент **O(N)**
- Представяне със свързани с указатели кутии
- Задължително има указател към първия елемент, възможно е 
  да има и към последния
  - Указател към последния елемент осигурява константна 
    сложност на операциите за добавяне в края, конкатенация 
    (сливане) на два списъка, четене в края. Минус е, че 
    изисква малко памет и предполага по-сложни операции
  - В стандартната библиотека `forward list` няма указател 
    към последния елемент
    ```
    first                               last
      ↓                                   ↓
    ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐
    │   │ *╴╴╴╴>│   │ *╴╴╴╴>│   │ *╴╴╴╴>│   │ / │
    └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘
    ```
- Клас итератор
  - Указател към текущия елемент `ptr`
  - Придвижване към следващия елемент
    - В зависимост от указателя може да се ползва само 
      придвижване към следващия или и към предишния
  - Понякога итераторът сочи към предходния на текущия 
    елемент, за да обработва добавяне и премахване на 
    текущата позиция
  - Възможно е итератор да е невалиден ако сочи към изтрит 
    обект
    - В повечето библиотеки не се гарантира валидност на 
      итераторите
    - Ползват се `smart pointers`, които да не позволяват 
      елемент да бъде изтрит докато има указатели към него, 
      но това може да предизвика обработка на елементи, 
      които не принадлежат на нито един списък
    - Итератор може да занае дали е валиден или не: задържа 
      в себе си своя собственик и своята версия и при всяка 
      промяна контейнер и итератор увеличават номера на 
      версията и ако са различни не се обработват
    - Възможно е собствник на итератор да е възелът, който 
      да държи в себе си всички итератори и да ги изтрива 
      ако самият възел бъде изтрит, но техниката не се 
      ползва често, понеже е неефективна
    - Сортирането и присвояването инвалидират итераторите
    ``` cpp
    List::Iterator it = l.begin();
    it++;
    ```
- За листи могат да се имплементират `map` (функция над 
  всички елементи), `filter` (извличане на елементи по 
  критерий), `accumulate/reduce` (обработка на всички 
  елементи едновременно, тяхната сума, произведение, но 
  задължително с начален контекст)
- При конкатенирането трябва да се укаже дали се премества 
  единия списък към другия или се копират стойностите
- Понякога се изисква метод `fixTail()` ако се наложи да се 
  редактира/поправи последният указател
- За да се копира списъка и да не се разглежда отделен 
  случай за първия елемент може да се създаде временен 
  възел, които да сочи към първия елемент
- Итераторите сочат предшественик на даден елемент и за 
  следващия елемент се ползват операциите за вмъкване и 
  премахване
- Възможно е да се изтрие елемент, към който сочи указател 
  като се замести с данните на следващия и се изтрие 
  следващия
- В някои от имплементациите е възможно да се ползва не 
  указател към първия елемент, а да се съхранява в класа
  - Това прави кода по-консистентен
- В списъци, в които последният елемент е свързан циклично 
  с някой от предишните елементи, образувайки подцикъл на 
  списъка, наречен атрактор. Алгоритъм за идентифициране на 
  такъв списък е като се създадат два указателя `slow`, 
  преместващ се с 1 стъпка на всяка итерация и `fast`, 
  който се премества с 2. Ако двата указателя съвпаднат 
  (сочат към един и същи елемент), то списъкът има 
  атрактор. Сложността е **O(2N)** понеже най-много 2 пъти 
  ще се обходи цикъла и ще се засекат.
- Function object

## Цикличен едносвързан списък _Linked List_
- Последният елемент на едносвързан списък е свързан с 
  първия и всеки е свързан със следващия
- Използва се само един указател
- Проверка при итерирането е сравняване с адреса на първия 
  елемент
- Положителна страна е че няма `nullptr`
- Всеки елемент има следващ, тоест `next` операцията винаги 
  е валидна
- Линеен едносвързан списък
  - Има начало/край
  - Явно празен списък
  - **О(1)** амортизиран достъп
  - **О(1)** добавяне/премахване на позиция
  - **О(N)** допълнителна памет
  - Разпръсната индиректна памет (ползва указатели)
  - По-удобни за конкурентен достъп
- Цикличен едносвързан списък
  - Всички елементи са еднакви
  - Няма `nullptr`
  - **О(1)** достъп
  - **О(1)** добавяне/премахване на позиция
  - **О(N)** допълнителна памет
  - Разпръсната индиректна памет (ползва указатели)
  - По-удобни за конкурентен достъп
- Масив
  - **О(1)** достъп
  - **О(N)** добавяне/премахване на позиция
  - Пространствена локалност (ефективно използване на CPU 
    кешовете)
  - Неефективен конкурентен достъп
- Ако се имплементира списък над масив `pool` с указатели 
  индексите на масива се ползват два списъка - с пълни и с 
  празни места в масива

## Линеен двусвързан списък _Doubly-linked List_
- Всеки елемент има два указателя - към следващия и към 
  предишния си елемент. Само първият и последният имат 
  `nullptr`.
- Позволява движение в две посоки
- Еднакъв достъп в двата края (`insert` и `remove` с 
  еднаква сложност)
- Силно симетрична структура
- Достъпът е по-бърз (ако е след средата се търси от края 
  напред)
- Всеки елемент е самодостатъчен за действия със себе си
- Вмъкване
  - Акцентира се, че кодът е напълно валиден и за списък 
    само с един елемент
    ``` cpp
    void insertFront(int data) {
      Node * n = new Node(data, nullptr, head);
      if(head) head->prev = n;
      else tail = n;
      head = n;
    }

    void insertEnd(int data) {
      Node * n = new Node(data, tail, nullptr);
      if(tail) tail->next = n;
      else head = n;
      tail = n;
    }

    void insertAfter() {
      assert(X);
      Node * n = new Node(data, X, X->next);
      X->next = n;
      if(n->next) n->next->prev = n;
      else tail = n;
    }

    void remove(node * X) {
      if(X->prev) X->prev->next = X->next;
      else head = X->next;
      if(X->next) X->next->prev = X->prev;
      else tail = X->prev;
      delete X;
    }
    ```
- Добре е да се направи тест на указателите
    ``` cpp
    assert(X == head && X->prev == nullptr ||
          X->next->prev == X && X->prev->next == X)
    ```
- `std::list` - Двусвързан списък
- `std::forward_list` - Едносвързан списък
- При двусвързаният цикличен списък последният елемент се 
  свързва с първия. Това представяне е удобно и често 
  използвано, понеже всеки елемент е самодостатъчен списък. 
  Има и допълнителен елемент `head`, който се задържа в 
  структурата.
- При сортиране двусвързаният списък се сортира като 
  едносвързан и след това се поправят указателите

- DLL
  - Симетричен достъп
  - Движение в две посоки
  - Самодостатъчност на елемент
- SLL
  - По-малко памет
  - По-прост код

------------------------------------------------------------
## Дървета
- Елементите имат предшественици и наследници
- Елементите имат единствен предшественик (родител) и 0 или 
  няколко наследници (деца)
- Единствен елемент без предшественик е коренът
- Всички наследници с общ родител се наричат братство
- Елементи без наследници се наричат листа
- Връзките между елементи се наричат ребра
- Дължина/височина на дървото се нарича най-дългият път, 
  започващ от корена и завършващ в листо
- Пътят от корена до определен елемент е единствен 
  (уникален)
- Дълбочина/ниво на елемент е дължината на пътя от корена 
  до елемента (нивото на корена е 0)
- Ниво в дървото е множеството от всички елементи с дадена 
  дълбочина в дървото
- Х е прародител на У ако Х е прародител или родител на 
  родител на У (родителите също се определят като 
  прародители)
- Поддърво (ЗА ДОПИСВАНЕ!!!)
- Всеки елемент уникално определя своето поддърво
- Разклоненост на дърво - брой на наследниците, които има 
  всеки един от елементите
- Ако максималният брой наследници за всеки елемент в дърво 
  е К, то дървото е регулярно от ред/степен К
- Тежест на дърво е броят на елементите в дътвото
- Елементите имат наредба, тя се определя като два елемента 
  от едно и също ниво се дефинират като десен или ляв брат
- Дърво, в което броят наследници на всеки елемент, който 
  не е листо има един и същ брой наследнии и всички листа 
  са на едно и също ниво
- Сложност на достъп до елемент с ниво l
  - ```c++
          ■
        / | \
       ■  ■  ■
     / |  |  | \
    ■  ■  ■  ■  ■
           /   \
          ■     ■
    ```
## Операции над дърво
- Намиране на елемент с определено свойство
  - Стойност, наследник/предшественик, поддъво с определени 
    свойства
- Добавяне на елемент - logN
- Премахване на елемент - logN
- Проверка на свойства - logN
  - Брой елементи, дали е празно, дали са добре разположени 
    елементите, разклоненост, дължина
- Обхождане
  - В широчина
  - В дълбочина
  - Ограничена дълбочина
## Реализация
-   ```c++
          ╔═══╗
          ║ 5 ║
          ╚╤╤╤╝
      ┌────┘│└───────┐
    ╔═╧═╗ ╔═╧═╗    ╔═╧═╗
    ║ 3 ║ ║ 2 ║    ║ 1 ║
    ╚═══╝ ╚═╤═╝    ╚╤═╤╝
            │     ┌─┘ └─┐
          ╔═╧═╗ ╔═╧═╗ ╔═╧═╗
          ║ 8 ║ ║ 1 ║ ║ 6 ║
          ╚═══╝ ╚═══╝ ╚═══╝
    ```
- Всеки елемент запазва своята стойност и списък от 
  наследници (масив, динамичен масив, свързан списък, др.)
  - Не е ефективно, понеже последният има празен масив с 
    дължина колкото разклонеността на дървото (ако масивите 
    са статични, трябва да са динамични за да е ефективно)
- Всеки елемент има указател към родителя си (всеки 
  елемент има единствен родител)
  - ```c++
    ┌──┬──┬──┬──┬──┬──┬──┐
    │ 5│ 3│ 2│ 1│ 8│ 1│ 6│ data
    └──┴──┴──┴──┴──┴──┴──┘
    ┌──┬──┬──┬──┬──┬──┬──┐
    │-1│ 0│ 0│ 0│ 2│ 3│ 3│ parent
    └──┴──┴──┴──┴──┴──┴──┘
    ```
  - Масив от всички елементи и масив със списък от 
    указатели кой към кого е свързан
  - Коренът е с -1
  - Нах-оптимално решение откъм паме, но не и най-ефективно 
    при ползване
- Реализация "ляв син десен брат"
  - Запазва се наследник и следващ брат
-   ```c++
          ╔═══╗             ╎ ╔═══╗
          ║ 5 ║             ╎ ║5 X║
          ╚╤╤╤╝             ╎ ║ * ║
      ┌────┘│└──────────┐   ╎ ╚═│═╝
    ╔═╧═╗ ╔═╧═╗       ╔═╧═╗ ╎ ╔═══╗ ╔═══╗             ╔═══╗
    ║ 3 ║ ║ 8 ║       ║ 2 ║ ╎ ║3 *──║8 *──────────────║2 X║
    ╚═══╝ ╚╤╤╤╝       ╚═╤═╝ ╎ ║ X ║ ║ * ║             ║ * ║
      ┌────┘│└────┐     │   ╎ ╚═══╝ ╚═│═╝             ╚═│═╝
    ╔═╧═╗ ╔═╧═╗ ╔═╧═╗ ╔═╧═╗ ╎       ╔═══╗ ╔═══╗ ╔═══╗ ╔═══╗
    ║ 4 ║ ║ 6 ║ ║ 1 ║ ║ 9 ║ ╎       ║4 *──║6 *──║1 X║ ║9 X║
    ╚═╤═╝ ╚═══╝ ╚═══╝ ╚═══╝ ╎       ║ * ║ ║ X ║ ║ X ║ ║ X ║
      │                     ╎       ╚═│═╝ ╚═══╝ ╚═══╝ ╚═══╝
    ╔═╧═╗                   ╎       ╔═══╗
    ║ 7 ║                   ╎       ║7 X║
    ╚═══╝                   ╎       ║ X ║
                            ╎       ╚═══╝
     [5] [3, 8, 2]          ╎ [5] [3][X]
     [3] [X]                ╎ [3] [X][8]
     [8] [4, 6, 1]          ╎ [8] [4][2]
     [2] [9]                ╎ [2] [9][X]
     [4] [7]                ╎ [4] [7][6]
     [6] [X]                ╎ [6] [X][1]
     [1] [X]                ╎ [1] [X][X]
     [9] [X]                ╎ [9] [X][X]
     [7] [X]                ╎ [7] [X][X]
    ```
- Реализация (информация-наследници-родител)
## Файлова система
- Файловата система е пример за дървовидна структура
# ----------------------------------------------------------
## Двоични дървета
- Регулярнидървета от ред 2 (всеки възел има не повече от 2 
  наследника)
- Лесно се представят във вида "ляв наследник десен брат"
- Най-простата нелинейна структура от данни
-   ```c++
    struct Node {
      T data;
      Node *left, * right;
    };
    ```
- Структура с N елемента може да се построи с дължина 
  Ω(log_2 (N))
- Малката дълбочина е плюс, понеже повечето операции вървят 
  по дължината на дървото
- Понеже е рекурсивна структура често се ползват рекурсивни 
  алгоритми
- Дървета, на които всеки елемент е с единствен наследник 
  не са ефективна структура заради това, че реално са 
  линейна структура с дължина O(N)
- Може да се добави `Node *parent`, за цената на по-сложни 
  операции и повече ползвана памет. Ползва се главно ако се 
  върви назад по дървото или извън процедура за търсене
- Целта на структурата дърво е да се съхрани информация за 
  последващо бързо търсене
  - Правим аналог с двоичното търсене
-   ```c++
    ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
    │ 05│ 07│ 08│ 10│ 12│ 15│ 18│ 22│ 25│ 30│
    └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
                         ╔═══╗
                         ║ 12║
                         ╚╤═╤╝
               ┌──────────┘ └──────────┐
             ╔═╧═╗                   ╔═╧═╗ 
             ║ 7 ║                   ║ 22║ 
             ╚╤═╤╝                   ╚╤═╤╝ 
         ┌────┘ └────┐           ┌────┘ └────┐
       ╔═╧═╗       ╔═╧═╗       ╔═╧═╗       ╔═╧═╗
       ║ 5 ║       ║ 8 ║       ║ 15║       ║ 25║
       ╚═══╝       ╚══╤╝       ╚══╤╝       ╚══╤╝
                      └─┐         └─┐         └─┐
                      ╔═╧═╗       ╔═╧═╗       ╔═╧═╗
                      ║ 10║       ║ 18║       ║ 30║
                      ╚═══╝       ╚═══╝       ╚═══╝
    ```
- Двоично дърво при което всички елементи вляво са 
  по-малки, а вдясно по-големи наричаме "Двоично дърво за 
  търсене", "Двоично наредено дърво" или "Binary Search 
  Tree" (BST)
- Има различни подходи за работа с еднакви елементи в BST:
  1. Да не се поддържат дублиращи се елементи - не се 
     запазват допълнително в дървото
  2. Да се записва за всеки елемент бройката на срещанията
  3. Да се вмъква новият (еднакъв) елемент винаги 
     вляво/вдясно - (евентуално на случаен принцип)
  4. Равните елементи да се допускат от 2те страни на 
     съответния корен
  - Ако има 2 елемента с еднаква стойност операцията 
    търсене ще намери елемента, който е по-близо до корена

- Основни операции на BST
> h - височина на дървото  
> LS - Left Subtree, RS - Right Subtree  
> n( ) - number of elements, h( ) - height, w( ) - weight  
  - Търсене по ключ - **O(h)**
  - Добавяне на елемент (винаги се добавя листо) - **O(h)** 
  - Премахване на елемент - **O(h)**
  - Информация за брой елементи, височина, дали отговаря на 
    някакво условие, дали е празен и т.н.
- Не се препоръчва да се връща псевдоним към елемент, 
  понеже елементът може да се промени. Вместо това се 
  ползва шаблонът `proxy`
- За търсене на елементи винтервал (или множество идентични 
  елементи) се намира елемент X от множеството и се 
  осъществява рекурсивно търсене за множествата X-ε вляво и 
  X+ε вдясно
- При добавяне на елемент се извършва рекурсивно сравняване 
  с всеки наследник на дадения корен и ако е по-малък се 
  разглежда лявата страна, ако е по-голям - дясната
- При добавяне и работа с идентични (дублиращи се) елементи 
  се процедира по избрания подход за работа
- Премахване на елемент:
  1. Намиране на елемент - **O(h)**
  2. 1. Няма наследници (листо е) - **O(1)**
     - Изтрива се елементът
     - Указателят на неговия родител се присвоява `nullptr`
     2. Има точно един наследник - **O(1)**
     - Изтрива се елементът
     - Поддървото на изтрития елемент се поставя на мястото 
       му (свързва се с родителя)
     3. Има два наследника - **O(h)**
     - Изтрива се елементът
     - В поддървото се продължава търсене за елемент с един 
       наследник
- Намиране на брой елементи:
  1. Ако е празно дърво = 0
  2. Ако не е празно = 1 + nElements(LS) + nElements(RS)
- Височина:
  1. Ако е празно дърво = 0
  2. Ако не е празно = 1 + max(height(LS), height(RS))
- Дърво е изродено ако наподобява линейна структура 
  log(N) < h ~ N
- Балансирано двоично дърво
  за ∀ елемент X: |h(X->LS) - h(X->RS)| <= 1
  - Идеално балансирано ДД по тегло
    за ∀ елемент X: |w(X->LS) - w(X->RS)| <= 1
  - Балансирано дърво може да се образува чрез стъпките на 
    двоично търсене, приложени за сортиран масив
  - Възможно е ипребалансиране на дървото ако достигне 
    някакво ниво, при което то не е балансирано
  - DSW алгоритъм за статично (offline) балансиране за O(N) 
    време и O(1) памет
  - Преливане в масив и построяване от масив - O(N) време и 
    O(N) памет (offline)
  - Online операциите за трансформации по време на работа - 
    самобалансиращи се дървета
    - AVL дърво, червено-черно дърво - баланс по височина
- Обхождане на дърво
-   ```c++
                         ╔═══╗
                         ║ 5 ║
                         ╚╤═╤╝
               ┌──────────┘ └──────────┐
             ╔═╧═╗                   ╔═╧═╗ 
             ║ 3 ║                   ║ 9 ║ 
             ╚╤═╤╝                   ╚╤═╤╝ 
         ┌────┘ └────┐           ┌────┘ └────┐
       ╔═╧═╗       ╔═╧═╗       ╔═╧═╗       ╔═╧═╗
       ║ 1 ║       ║ 4 ║       ║ 7 ║       ║ 11║
       ╚═══╝       ╚═══╝       ╚═══╝       ╚╤══╝
                                          ┌─┘
                                        ╔═╧═╗
                                        ║ 10║
                                        ╚═══╝
    ```
  - Корен -> Ляво -> Дясно (Префиксно)
    - 5 3 1 4 9 7 11 10
    - Първо се преминава през по-високите елементи 
      (родителите)
    - Ползва се при копиране, търсене, вмъкване
  - Ляво -> Корен -> Дясно (Инфиксно)
    - 1 3 4 5 7 9 10 11
    - Получава се сортирано обхождане
  - Ляво -> Дясно -> Корен (Постфиксно)
    - 1 4 3 7 10 11 9
    - Първо се преминава през по-ниските елементи (листата)
    - Ползва се при изтриване
-   ```c++
    //Iterative search algorithm
    node* current = root;
    while (current) {
      if (current->key == key) return true;
      current = 
      current->key < key ? current->right : current->left;
    }
    ```
------------------------------------------------------------
## Дървета _Trees_
### Дървета, терминология
- Листо
  - Елемент без наследници
- Височина на дърво `h`
  - Най-дълъг път от корена до листо
- Тегло на дърво `w()`
  - Брой на елементите в дървото `N`
- Дълбочина на възел `h()`  
  - Дължината на пътя от корена до този елемент
- Ниво `l`
  - Всички елементи с дадена дълбочина
- Разклоненост на възел
  - Брой на наследниците на възел
- Разклоненост на дърво (коефициент) `k`
  - Най-голямата разклоненост на възел
- Регулярност на дърво
  - Фиксирана максимална разклоненост за всеки възел
- Пълно дърво
  - Дърво при което всички върхове, които не са листа са с 
    максимална разклоненост
  - На всяко ниво има максимално $k^l$ елемента
- Стриктна дефиници за дърво
  - Всички листа са разположени на последните 2 нива
- Изродено/линейно дърво (Vine)
  - Представяне на дърво като свързан списък
  - Регулярност 1 при линейна структура
  - $h \gg log_k(N), h ≈ N$
- Пълно дърво - h ∈ (log(N))
- Релация в дърво `T`
    $h(T) ≥ log_k(w(T))$
### Операции в дървета
- Операциите върху дървета са пропорционални на височината, 
  операции със сложност **O(h)**, **Θ(h)**
- При задачи за дървета се уточнява дали коренът е с 
  дълбочина 0 или 1
- Търсене
  - За да бъде функцията за търсенето в дърво със сложност 
    **O(h)** е необходимо по търсен връх Y и начален връх 
    за търсене X с поддървета A, B и C, за константно време 
    функцията `select(X, Y)` да определя в кое от 
    поддърветата на X може да се намира Y
  - Селектиращата функция `select(X, Y)` ∈ **O(k)**, но се 
    счита за **O(1)** за малки стойности на константата
- Сложност на операции
  - `Find`, `Insert`, `Remove` - **O(log(N))**
  - `Index`
    - С променливи за височината на дърветата (DOS) 
      **O(log(N))**
    - С обхождане Left-Parent-Right **O(N)**
### Дървета, имплементация
- Представяне с родител на елемент
  - Минималната необходима памет за съхраняване на дърво е 
    за ключовете (стойностите) на върховете и връзките към 
    техните родители
  - Най-кондензирано представяне, ползва се само за 
    съхранение на дървото в малко памет (сериализация)
    N елемента + N ключа
  - Не може лесно и бързо да се намерят наследниците на 
    даден връх, най често е с **O(N)** сложност
    ```
                   ┌───┐
                   │ 1 │
                   └┬┬┬┘
         ┌──────────┘│└───────┐
       ┌─┴─┐       ┌─┴─┐    ┌─┴─┐
       │ 2 │       │ 3 │    │ 4 │
       └┬─┬┘       └┬─┬┘    └─┬─┘
      ┌─┘ └─┐     ┌─┘ └─┐     │
    ┌─┴─┐ ┌─┴─┐ ┌─┴─┐ ┌─┴─┐ ┌─┴─┐
    │ 5 │ │ 6 │ │ 7 │ │ 8 │ │ 10│
    └───┘ └─┬─┘ └───┘ └───┘ └───┘
            │
          ┌─┴─┐
          │ 9 │     Елемент | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|
          └───┘     Родител | 0| 1| 1| 1| 2| 2| 3| 3| 6| 4|
    ```
- Списък с наследници
  - Всеки елемент притежава списък със своите наследници, 
    използва се статичен (с размер на разклонеността на 
    дървото) или динамичен масив. Може да се ползва и хеш 
    таблица за контейнер, но се губи доста от паметта за 
    ефективни таблици.
  - Достъп до пореден елемент, който е наследник на друг е 
    със сложност **O(1)**
  - Може в самата структура да се пази списък с указатели 
    към наследниците или само указател към списъка. Ако се 
    пазят указателите в същата структура locality ще работи 
    по-ефективно. Но в този случай ще има неизползвана 
    памет за празните указатели във всяка структура (при 
    дървета, в които елементите нямат максимален брой 
    наследници и при листата, като евентуално за листата 
    може да се ползва друга структура).
  - Представяне като структури със стойност `key` и 
    наследници `children`
      ``` cpp
      struct node {
        int key;
        node* children[8];
      }
      ```
- Left child right sibling представяне
  - Всеки елемент има един указател към следващото ниво и 
    един към съседен елемент
  - Лесен за реализация, не е необходим допълнителен 
    контейнер
  - Трудно се обхожда по стандартен начин

## Двоично наредено дърво (двоично дърво за търсене) BST
- За всеки елемент от дървото, вляво (ляво поддърво) се 
  намират по-малките, а в дясно по-големите от него 
  елементи
- Добавяне на повече от един елемент
- При добавяне на повече от един елемент с една и съща 
  стойност има следните възможни имплементации:
  - Не се добавя, отхвърля се
  - Опреснява се елементът (за съставни елементи с повече 
    от една характеристика)
  - В брояч се добавя още една бройка (за неразличими 
    елементи)
  - Запазва се контейнер bucket с елементите (за различими 
    елементи)
  - Допуска се равенство в едната или и двете страни
    - Равенството от двете страни предизвиква проблеми при 
      търсене или броене, понеже се обхождат и двете 
      поддървета
    - Ако има елементи с равни стойности и в двете 
      поддървета на корен, то те съвпадат с корена
    - Сложност на търсене на всички елементи с даден ключ 
      O(k) + O(h)
- Изродени BST дървета
    ```
       03              N = 9
      ╱  ╲             h = 6
    01    04
            ╲
             07
            ╱  ╲
          05    08
                  ╲
                   13
                  ╱  ╲
                11    15
    ```

## Балансирани BST дървета
- Метрика за характеристика на дървета
- Балансирано по височина - за всеки елемент, разликата във 
  височината на двете поддървета не е по-голяма от 1
  $∀ X: |h(X_l) - h(X_r)| ≤ 1$
- Балансирано по тегло - за всеки елемент, разликата в 
  теглата на двете поддървета не е по-голяма от 1. Нарича 
  се също идеалнобалансирано
  $∀ X: |w(X_l) - w(X_r)| ≤ 1$
- Не за всички дървета може да има случай, в който балансът 
  на елементите е = 0, затова ползваме ≤ 1, например дърво 
  с 4 елемента
- Всяко балансирано по тегло дърво е балансирано и по 
  височина
  $Bw ⇒ Bh$
- За всяко балансирано по тегло дърво Bw с тегло w (брой на 
  елементи в дървото):
  $h(Bw) ≤ log_2(w) + 1$
- За всяко балансирано по височина дърво Bh с тегло w (брой 
  на елементи в дървото):
  $h(Bh) ≤ c_1*log_2(w) + c_2,$
  $където c_1 и c_2 са константи$
  $h(Bh) ≤ 2*log_2(w) + 2$ 
- Балансираните по тегло дървета са по-трудни за поддръжка 
  от тези по височина

## Практическа необходимост от Балансирани дървета
- Търсенето на елемент, който се намира в дървото е 
  по-ефективно в общия случай от елемент, който не е от 
  дървото понеже при намирането му търсенето се прекратява, 
  а в другия случай е необходимо да се стигне до листата на 
  дървото
- За балансирани дървета приблизително 50% от елементите се 
  намират в листата

- Примерна задача:
  Търсене на стойност сред дадено множество
  - Линейно търсене - **O(N)**
  - Сортиране и двоично търсене - **O(log(N))**
  - BST - **O(log(N))**
  - Хеш таблица - **O(1)**
- Построяването на дърво има смисъл за K броя заявки, 
  когато за дърво с N елемента $K > log_2(N)$, а при 
  достатъчно малки стойности за N също има смисъл да се 
  ползва линейно търсене (полза от locality)

## Тривиални методи за построяване на BST
- Тривиален начин за построяване на BST от дадени стойности 
  е ползването на сортиран масив с данните. Средата на 
  масива е корен, а лявата и дясната част са двете 
  поддървета, за които отново рекурсивно средите са корени
- Полученото дърво, по построение, е балансирано по тегло, 
  следователно е балансирано и по височина
    ```
    Пример:
    Индекс    | 0| 1| 2| 3| 4| 5| 6| 7| 8|        12
    Елементи  | 3|12| 5|22|14|17|28| 7| 9|     ┌───┴───┐
    Сортирани | 3| 5| 7| 9|12|14|17|22|28|     7      22
              | -  -  -  -  +  -  -  -  -|   ┌─┴─┐   ┌─┴─┐
              | -  -  +  -     -  -  +  -|   5   9  17  28
              | -  +     +     -  +     -|   │       │
                                             3      14
    ```

------------------------------------------------------------

# Notes
- СДП - ФМИ - 2021г. 2022г.
- Всички записки са направени благодарение на лекторите по 
  предмета - П. Армянов, А. Семерджиев